;;; An operation in the term language.
(datatype MathOp
   (Add)
   (Sub)
   (Mul)
   (Div)
   (Abs))

(datatype PredOp
    (Eq)
    (Neq))

;;; The root term language we're using.
(datatype Math
  (Num i64)
  (Var String)
  (MathOp1 MathOp Math)
  (MathOp2 MathOp Math Math))

;;; predicates!
(datatype Pred
     ;;; Just a term across two math exprs, e.g. "(Op2 (Eq) (Var "x") (Var "y"))".
     (PredOp1 PredOp Math)
     (PredOp2 PredOp Math Math))

(datatype PredCvec
  (PredNil)
  (PredCons bool PredCvec))

;;; Cvecs ;;;
(datatype OptionI64
  (None)
  (Some i64))

(datatype MathCvec
  (MathCvecNil)
  (MathCvecCons OptionI64 MathCvec))

(relation HasMathCvec (Math MathCvec))

(relation HasPredCvec (Pred PredCvec))

;;; Semantics for the atoms of the term language.
(rule
  ((Num ?n))
  ((HasMathCvec (Num ?n)
                (MathCvecCons (Some ?n)
                (MathCvecCons (Some ?n)
                (MathCvecCons (Some ?n)
                (MathCvecNil)))))))

(rule
  ((Var ?x))
  ((HasMathCvec (Var ?x)
                (MathCvecCons (Some -1)
                (MathCvecCons (Some 0)
                (MathCvecCons (Some 1)
                (MathCvecNil)))))))

(function mapMathOp1 (MathOp MathCvec) MathCvec)
(function mapMathOp2 (MathOp MathCvec MathCvec) MathCvec)

(function mapPredOp2 (PredOp MathCvec MathCvec) PredCvec)

;;; base cases for mapping functions across cvecs.

(rewrite
  (mapMathOp1 ?fn (MathCvecNil))
  (MathCvecNil))

(rewrite
  (mapMathOp2 ?fn (MathCvecNil) (MathCvecNil))
  (MathCvecNil))

(rule
  ((mapMathOp2 ?fn (MathCvecNil) (MathCvecCons ?head ?tail)))
  ((panic "mapMathOp2: unequal cvec lengths")))

(rule
  ((mapMathOp2 ?fn (MathCvecCons ?head ?tail) (MathCvecNil)))
  ((panic "mapMathOp2: unequal cvec lengths")))

(rule
  ((mapPredOp2 ?fn (MathCvecNil) (MathCvecCons ?head ?tail)))
  ((panic "mapPredOp2: unequal cvec lengths")))

(rule
  ((mapPredOp2 ?fn (MathCvecCons ?head ?tail) (MathCvecNil)))
  ((panic "mapPredOp2: unequal cvec lengths")))

(rewrite
 (mapPredOp2 ?fn (MathCvecNil) (MathCvecNil))
 (PredNil))

(rule
 ((mapPredOp2 (Eq)
            (MathCvecCons ?n ?tail1)
            (MathCvecCons ?m ?tail2))
  (= ?n ?m))
 ((union (mapPredOp2 (Eq)
            (MathCvecCons ?n ?tail1)
            (MathCvecCons ?m ?tail2))
         (PredCons true (mapPredOp2 (Eq) ?tail1 ?tail2)))))

(rule
 ((mapPredOp2 (Eq)
            (MathCvecCons ?n ?tail1)
            (MathCvecCons ?m ?tail2))
  (!= ?n ?m))
 ((union (mapPredOp2 (Eq)
            (MathCvecCons ?n ?tail1)
            (MathCvecCons ?m ?tail2))
         (PredCons false (mapPredOp2 (Eq) ?tail1 ?tail2)))))

(rule
 ((mapPredOp2 (Neq)
            (MathCvecCons ?n ?tail1)
            (MathCvecCons ?m ?tail2))
  (!= ?n ?m))
 ((union (mapPredOp2 (Neq)
            (MathCvecCons ?n ?tail1)
            (MathCvecCons ?m ?tail2))
         (PredCons true (mapPredOp2 (Neq) ?tail1 ?tail2)))))

(rule
 ((mapPredOp2 (Neq)
            (MathCvecCons ?n ?tail1)
            (MathCvecCons ?m ?tail2))
  (= ?n ?m))
 ((union (mapPredOp2 (Neq)
            (MathCvecCons ?n ?tail1)
            (MathCvecCons ?m ?tail2))
         (PredCons false (mapPredOp2 (Neq) ?tail1 ?tail2)))))

;;; assign a predicate cvec to predicate, (t1, t2)
(rule
 ((PredOp2 ?op ?term1 ?term2)
  (HasMathCvec ?term1 ?cvec1)
  (HasMathCvec ?term2 ?cvec2))
 ((HasPredCvec (PredOp2 ?op ?term1 ?term2)
               (mapPredOp2 ?op ?cvec1 ?cvec2))))

(rewrite
 (mapMathOp2
  (Add)
  (MathCvecCons (Some ?n1) ?tail1)
  (MathCvecCons (Some ?n2) ?tail2))
 (MathCvecCons (Some (+ ?n1 ?n2))
       (mapMathOp2 (Add) ?tail1 ?tail2)))

(rewrite
 (mapMathOp2
  (Sub)
  (MathCvecCons (Some ?n1) ?tail1)
  (MathCvecCons (Some ?n2) ?tail2))
 (MathCvecCons (Some (- ?n1 ?n2))
       (mapMathOp2 (Sub) ?tail1 ?tail2)))

(rewrite
 (mapMathOp2
  (Mul)
  (MathCvecCons (Some ?n1) ?tail1)
  (MathCvecCons (Some ?n2) ?tail2))
 (MathCvecCons (Some (* ?n1 ?n2))
       (mapMathOp2 (Mul) ?tail1 ?tail2)))

(rule
 ((mapMathOp2
  (Div)
  (MathCvecCons (Some ?n1) ?tail1)
  (MathCvecCons (Some ?n2) ?tail2))
  (!= ?n2 0))
 ((union
  (mapMathOp2
   (Div)
   (MathCvecCons (Some ?n1) ?tail1)
   (MathCvecCons (Some ?n2) ?tail2))
   (MathCvecCons (Some (/ ?n1 ?n2))
       (mapMathOp2 (Div) ?tail1 ?tail2)))))

(rule
 ((mapMathOp2
  (Div)
  (MathCvecCons (Some ?n1) ?tail1)
  (MathCvecCons (Some ?n2) ?tail2))
  (= ?n2 0))
 ((union
  (mapMathOp2
   (Div)
   (MathCvecCons (Some ?n1) ?tail1)
   (MathCvecCons (Some ?n2) ?tail2))
   (MathCvecCons (None)
       (mapMathOp2 (Div) ?tail1 ?tail2)))))

(rule
 ((MathOp2 ?op ?e1 ?e2)
  (HasMathCvec ?e1 ?cvec1)
  (HasMathCvec ?e2 ?cvec2))
 ((HasMathCvec
  (MathOp2 ?op ?e1 ?e2)
  (mapMathOp2 ?op ?cvec1 ?cvec2))))


;;; potential rules.

(relation Rule (Math Math))
(relation CondRule (Pred Math Math))

(rule
 ((HasMathCvec ?term1 ?cvec)
  (HasMathCvec ?term2 ?cvec)
  (!= ?term1 ?term2))
 ((extract "no pred:")
  (extract "t1:")
  (extract ?term1)
  (extract "t2:")
  (extract ?term2)
  (Rule ?term1 ?term2)))

;;; conditional rules.

(relation HasMatch (PredCvec MathCvec MathCvec))

;; handle the base case.
(HasMatch (PredNil) (MathCvecNil) (MathCvecNil))

;; recursive case: p1 -> (c1 == c2)

(rule
 ((PredCons ?p1 ?ptail)
  (MathCvecCons ?c1 ?tail1)
  (MathCvecCons ?c2 ?tail2)
  (= ?p1 true)
  (= ?c1 ?c2)
  (HasMatch ?ptail ?tail1 ?tail2))
 ((HasMatch
  (PredCons ?p1 ?ptail)
  (MathCvecCons ?c1 ?tail1)
  (MathCvecCons ?c2 ?tail2))))

;; recursive case: !p1 -> (c1 != c2)
(rule
 ((PredCons ?p1 ?ptail)
  (MathCvecCons ?c1 ?tail1)
  (MathCvecCons ?c2 ?tail2)
  (!= ?p1 true)
  (!= ?c1 ?c2)
  (HasMatch ?ptail ?tail1 ?tail2))
 ((HasMatch
  (PredCons ?p1 ?ptail)
  (MathCvecCons ?c1 ?tail1)
  (MathCvecCons ?c2 ?tail2))))

(rule
 ((HasMathCvec ?t1 ?c1)
  (HasMathCvec ?t2 ?c2)
  (HasPredCvec ?pred ?p1)
  (HasMatch ?p1 ?c1 ?c2))
 ((CondRule ?pred ?t1 ?t2)
  (extract "pred:")
  (extract ?pred)
  (extract "t1:")
  (extract ?t1)
  (extract "t2:")
  (extract ?t2)))

; (ruleset
;  cleanup)
; 
; (rule
;   ((zip2 ?op ?e1 ?e2))
;   ((delete (zip2 ?op ?e1 ?e2)))
;   :ruleset cleanup)
; 
; (rule
;   ((predzip2 ?op ?e1 ?e2))
;   ((delete (predzip2 ?op ?e1 ?e2)))
;   :ruleset cleanup)
; 
; (rule
;   ((HasMatch ?blah ?blah1 ?blah2))
;   ((delete (HasMatch ?blah ?blah1 ?blah2)))
;   :ruleset cleanup)

(Var "x")
(Num 0)
(Num 1)
(MathOp2 (Div) (Var "x") (Var "x"))
(PredOp2 (Neq) (Var "x") (Num 0))

(run 100)
