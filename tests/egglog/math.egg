;;; ugh... there's something wrong with my current implementation of
;;; option that makes things blow up.
;;; resorting to old style of creating non-generic options here:
;;; TODO(@ninehusky): investigate! (see #2).


;;; the sorts "Math" and "Pred"
;;; should already be predefined.

(datatype PredOp
    (Eq)
    (Neq))

(function PredOp2 (PredOp Math Math) Pred)

(datatype MathOp
    (Add)
    (Sub)
    (Mul)
    (Div)
    (Abs))

(function Num (i64) Math)
(function Var (String) Math)

(function MathOp1 (MathOp Math) Math)
(function MathOp2 (MathOp Math Math) Math)

;;; cvecs

(sort OptionI64 (Option i64))

(datatype MathCvec
   (MathNil)
   (MathCons OptionI64 MathCvec))

(relation HasMathCvec (Math MathCvec))

(sort OptionBool (Option bool))
(datatype PredCvec
   (PredNil)
   (PredCons OptionBool PredCvec))

(relation HasPredCvec (Pred PredCvec))

;;; maps over cvecs
(function applyMathOp2 (MathOp MathCvec MathCvec) MathCvec)
(function applyPredOp2 (PredOp MathCvec MathCvec) PredCvec)

(rewrite
  (applyMathOp2 ?op (MathNil) (MathNil))
  (MathNil))

(rewrite
  (applyPredOp2 ?op (MathNil) (MathNil))
  (PredNil))

(rule
  ((applyMathOp2 ?fn (MathNil) (MathCons ?head ?tail)))
  ((panic "applyMathOp2: unequal cvec lengths")))

(rule
  ((applyMathOp2 ?fn (MathCons ?head ?tail) (MathNil)))
  ((panic "applyMathOp2: unequal cvec lengths")))

;;; math rules:

(rule ((Num ?n)) ((HasMathCvec (Num ?n)
    (MathCons (option-some ?n)
      (MathCons (option-some ?n)
      (MathCons (option-some ?n)
      (MathCons (option-some ?n)
      (MathCons (option-some ?n)
      (MathCons (option-some ?n)
      (MathCons (option-some ?n)
      (MathCons (option-some ?n)
      (MathCons (option-some ?n)
      (MathCons (option-some ?n)
      (MathNil))))))))))))))

(rule
  ((Var ?v))
  ((HasMathCvec (Var ?v)
    (MathCons (option-some -5)
      (MathCons (option-some -4)
      (MathCons (option-some -3)
      (MathCons (option-some -2)
      (MathCons (option-some -1)
      (MathCons (option-some 0)
      (MathCons (option-some 1)
      (MathCons (option-some 2)
      (MathCons (option-some 3)
      (MathCons (option-some 4)
      (MathNil))))))))))))))

 (rewrite
   (applyMathOp2 (Add)
     (MathCons (option-some ?n) ?tail1)
     (MathCons (option-some ?m) ?tail2))
   (MathCons (option-some (+ ?n ?m))
     (applyMathOp2 (Add) ?tail1 ?tail2)))

 (rewrite
   (applyMathOp2 (Sub)
     (MathCons (option-some ?n) ?tail1)
     (MathCons (option-some ?m) ?tail2))
   (MathCons (option-some (- ?n ?m))
     (applyMathOp2 (Sub) ?tail1 ?tail2)))

 (rewrite
   (applyMathOp2 (Mul)
     (MathCons (option-some ?n) ?tail1)
     (MathCons (option-some ?m) ?tail2))
   (MathCons (option-some (* ?n ?m))
     (applyMathOp2 (Mul) ?tail1 ?tail2)))

 (rule
   ((applyMathOp2 (Div)
     (MathCons (option-some ?n) ?tail1)
     (MathCons (option-some ?m) ?tail2))
     (!= ?m 0))
   ((union
       (applyMathOp2 (Div)
         (MathCons (option-some ?n) ?tail1)
         (MathCons (option-some ?m) ?tail2))
       (MathCons (option-some (/ ?n ?m))
         (applyMathOp2 (Div) ?tail1 ?tail2)))))

 (rule
   ((applyMathOp2 (Div)
     (MathCons (option-some ?n) ?tail1)
     (MathCons (option-some ?m) ?tail2))
     (= ?m 0))
   ((union
       (applyMathOp2 (Div)
         (MathCons (option-some ?n) ?tail1)
         (MathCons (option-some ?m) ?tail2))
       (MathCons (option-none)
         (applyMathOp2 (Div) ?tail1 ?tail2)))))

;;; predicate rules:


;;; find non-conditional rules.
(rule
  ((HasMathCvec ?a ?cvec)
   (HasMathCvec ?b ?cvec)
   (!= ?a ?b))
  ((Rule ?a ?b)))

; (let expr0 (Var "x"))

(run 10000)
