;;; the sorts "Math" and "Pred"
;;; should already be predefined.

(datatype PredOp
    (Eq)
    (Neq))

(function PredOp2 (PredOp Math Math) Pred)

(datatype MathOp
    (Add)
    (Sub)
    (Mul)
    (Div)
    (Abs))

(function Num (i64) Math)
(function Var (String) Math)

(function MathOp1 (MathOp Math) Math)
(function MathOp2 (MathOp Math Math) Math)

;;; cvecs

(datatype OptionI64
  (None)
  (Some i64))

(datatype MathCvec
   (MathNil)
   (MathCons OptionI64 MathCvec))

(relation HasMathCvec (Math MathCvec))

(sort OptionBool (Option bool))
(datatype PredCvec
   (PredNil)
   (PredCons OptionBool PredCvec))

(relation HasPredCvec (Pred PredCvec))

;;; maps over cvecs
(function applyMathOp1 (MathOp MathCvec) MathCvec)
(function applyMathOp2 (MathOp MathCvec MathCvec) MathCvec)
(function applyPredOp2 (PredOp MathCvec MathCvec) PredCvec)

(rewrite
  (applyMathOp2 ?op (MathNil) (MathNil))
  (MathNil))

(rewrite
  (applyPredOp2 ?op (MathNil) (MathNil))
  (PredNil))

(rule
  ((applyMathOp2 ?fn (MathNil) (MathCons ?head ?tail)))
  ((panic "applyMathOp2: unequal cvec lengths")))

(rule
  ((applyMathOp2 ?fn (MathCons ?head ?tail) (MathNil)))
  ((panic "applyMathOp2: unequal cvec lengths")))

;;; math rules:

(rule ((Num ?n)) ((HasMathCvec (Num ?n)
    (MathCons (Some ?n)
      (MathCons (Some ?n)
      (MathCons (Some ?n)
      (MathCons (Some ?n)
      (MathCons (Some ?n)
      (MathCons (Some ?n)
      (MathCons (Some ?n)
      (MathCons (Some ?n)
      (MathCons (Some ?n)
      (MathCons (Some ?n)
      (MathNil))))))))))))))

(rule
  ((Var ?v))
  ((HasMathCvec (Var ?v)
    (MathCons (Some -5)
      (MathCons (Some -4)
      (MathCons (Some -3)
      (MathCons (Some -2)
      (MathCons (Some -1)
      (MathCons (Some 0)
      (MathCons (Some 1)
      (MathCons (Some 2)
      (MathCons (Some 3)
      (MathCons (Some 4)
      (MathNil))))))))))))))

(rule
  ((MathOp2 ?op ?term1 ?term2)
   (HasMathCvec ?term1 ?cvec1)
   (HasMathCvec ?term2 ?cvec2))
  ((HasMathCvec (MathOp2 ?op ?term1 ?term2)
   (applyMathOp2 ?op ?cvec1 ?cvec2))))

 (rewrite
   (applyMathOp2 (Add)
     (MathCons (Some ?n) ?tail1)
     (MathCons (Some ?m) ?tail2))
   (MathCons (Some (+ ?n ?m))
     (applyMathOp2 (Add) ?tail1 ?tail2)))

 (rewrite
   (applyMathOp2 (Sub)
     (MathCons (Some ?n) ?tail1)
     (MathCons (Some ?m) ?tail2))
   (MathCons (Some (- ?n ?m))
     (applyMathOp2 (Sub) ?tail1 ?tail2)))

 (rewrite
   (applyMathOp2 (Mul)
     (MathCons (Some ?n) ?tail1)
     (MathCons (Some ?m) ?tail2))
   (MathCons (Some (* ?n ?m))
     (applyMathOp2 (Mul) ?tail1 ?tail2)))

 (rule
   ((applyMathOp2 (Div)
     (MathCons (Some ?n) ?tail1)
     (MathCons (Some ?m) ?tail2))
     (!= ?m 0))
   ((union
       (applyMathOp2 (Div)
         (MathCons (Some ?n) ?tail1)
         (MathCons (Some ?m) ?tail2))
       (MathCons (Some (/ ?n ?m))
         (applyMathOp2 (Div) ?tail1 ?tail2)))))

 (rule
   ((applyMathOp2 (Div)
     (MathCons (Some ?n) ?tail1)
     (MathCons (Some ?m) ?tail2))
     (= ?m 0))
   ((union
       (applyMathOp2 (Div)
         (MathCons (Some ?n) ?tail1)
         (MathCons (Some ?m) ?tail2))
       (MathCons (None)
         (applyMathOp2 (Div) ?tail1 ?tail2)))))

;;; predicate rules:

;;; find non-conditional rules.
(rule
  ((HasMathCvec ?a ?cvec)
   (HasMathCvec ?b ?cvec)
   (!= ?a ?b))
  ((Rule ?a ?b)))

(let expr1 (MathOp2 (Add) (Num 1) (Var "x")))
(let expr2 (MathOp2 (Add) (Var "x") (Num 1)))
(run 10000)
