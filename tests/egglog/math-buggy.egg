;;; ugh... there's something wrong with my current implementation of
;;; option that makes things blow up.
;;; resorting to old style of creating non-generic options here:
(sort Math)
(sort Pred)

(datatype MathOption
   (MathNone)
   (MathSome i64))

;;; AHH!! rules are borken too!
(datatype Rule
   (NormalRule Math Math)
   (ConditionalRule Pred Math Math))

(sort RuleSet (Set Rule))

(datatype PredOp
    (Eq)
    (Neq))

(function PredOp2 (PredOp Math Math) Pred)

(datatype MathOp
    (Add)
    (Sub)
    (Mul)
    (Div)
    (Abs))

(function Num (i64) Math)
(function Var (String) Math)

(function MathOp1 (MathOp Math) Math)
(function MathOp2 (MathOp Math Math) Math)

;;; cvecs


(datatype MathCvec
   (MathNil)
   (MathCons MathOption MathCvec))

(relation HasMathCvec (Math MathCvec))

(datatype PredCvec
   (PredNil)
   (PredCons bool PredCvec))

(relation HasPredCvec (Pred PredCvec))

;;; maps over cvecs
(function applyMathOp2 (MathOp MathCvec MathCvec) MathCvec)
(function applyPredOp2 (PredOp MathCvec MathCvec) PredCvec)

(rewrite
  (applyMathOp2 ?op (MathNil) (MathNil))
  (MathNil))

(rewrite
  (applyPredOp2 ?op (MathNil) (MathNil))
  (PredNil))

(rule
  ((applyMathOp2 ?fn (MathNil) (MathCons ?head ?tail)))
  ((panic "applyMathOp2: unequal cvec lengths")))

(rule
  ((applyMathOp2 ?fn (MathCons ?head ?tail) (MathNil)))
  ((panic "applyMathOp2: unequal cvec lengths")))

;;; semantics for the term language:

(rule ((Num ?n)) ((HasMathCvec (Num ?n)
      (MathCons (MathSome ?n)
      (MathCons (MathSome ?n)
      (MathNil))))))

(rule
  ((Var ?v))
  ((HasMathCvec (Var ?v)
      (MathCons (MathSome 0)
      (MathCons (MathSome 1)
      (MathNil))))))

 (rewrite
   (applyMathOp2 (Add)
     (MathCons (MathSome ?n) ?tail1)
     (MathCons (MathSome ?m) ?tail2))
   (MathCons (MathSome (+ ?n ?m))
     (applyMathOp2 (Add) ?tail1 ?tail2)))

 (rewrite
   (applyMathOp2 (Sub)
     (MathCons (MathSome ?n) ?tail1)
     (MathCons (MathSome ?m) ?tail2))
   (MathCons (MathSome (- ?n ?m))
     (applyMathOp2 (Sub) ?tail1 ?tail2)))

 (rewrite
   (applyMathOp2 (Mul)
     (MathCons (MathSome ?n) ?tail1)
     (MathCons (MathSome ?m) ?tail2))
   (MathCons (MathSome (* ?n ?m))
     (applyMathOp2 (Mul) ?tail1 ?tail2)))

 (rule
   ((applyMathOp2 (Div)
     (MathCons (MathSome ?n) ?tail1)
     (MathCons (MathSome ?m) ?tail2))
     (!= ?m 0))
   ((union
       (applyMathOp2 (Div)
         (MathCons (MathSome ?n) ?tail1)
         (MathCons (MathSome ?m) ?tail2))
       (MathCons (MathSome (/ ?n ?m))
         (applyMathOp2 (Div) ?tail1 ?tail2)))))

 (rule
   ((applyMathOp2 (Div)
     (MathCons (MathSome ?n) ?tail1)
     (MathCons (MathSome ?m) ?tail2))
     (= ?m 0))
   ((union
       (applyMathOp2 (Div)
         (MathCons (MathSome ?n) ?tail1)
         (MathCons (MathSome ?m) ?tail2))
       (MathCons (MathNone)
         (applyMathOp2 (Div) ?tail1 ?tail2)))))

(rule
  ((MathOp2 (Add) ?e1 ?e2)
   (HasMathCvec ?e1 ?cvec1)
   (HasMathCvec ?e2 ?cvec2))
  ((HasMathCvec
   (MathOp2 (Add) ?e1 ?e2)
   (applyMathOp2 (Add) ?cvec1 ?cvec2))))

;;; semantics for the predicate language:
(rule
  ((applyPredOp2 (Eq)
      (MathCons ?n ?tail1)
      (MathCons ?m ?tail2))
   (= ?n ?m))
  ((union (applyPredOp2 (Eq)
      (MathCons ?n ?tail1)
      (MathCons ?m ?tail2))
      (PredCons true
        (applyPredOp2 (Eq) ?tail1 ?tail2)))))

(rule
  ((applyPredOp2 (Eq)
      (MathCons ?n ?tail1)
      (MathCons ?m ?tail2))
   (!= ?n ?m))
  ((union (applyPredOp2 (Eq)
      (MathCons ?n ?tail1)
      (MathCons ?m ?tail2))
      (PredCons false
        (applyPredOp2 (Eq) ?tail1 ?tail2)))))

(rule
  ((applyPredOp2 (Neq)
      (MathCons ?n ?tail1)
      (MathCons ?m ?tail2))
   (!= ?n ?m))
  ((union (applyPredOp2 (Neq)
      (MathCons ?n ?tail1)
      (MathCons ?m ?tail2))
      (PredCons true
        (applyPredOp2 (Neq) ?tail1 ?tail2)))))

(rule
  ((applyPredOp2 (Neq)
      (MathCons ?n ?tail1)
      (MathCons ?m ?tail2))
   (= ?n ?m))
  ((union (applyPredOp2 (Neq)
      (MathCons ?n ?tail1)
      (MathCons ?m ?tail2))
      (PredCons false
        (applyPredOp2 (Neq) ?tail1 ?tail2)))))

(rule
  ((PredOp2 ?op ?term1 ?term2)
   (HasMathCvec ?term1 ?cvec1)
   (HasMathCvec ?term2 ?cvec2))
  ((HasPredCvec (PredOp2 ?op ?term1 ?term2)
                (applyPredOp2 ?op ?cvec1 ?cvec2))))

;;; rules:
;;; contains a dummy rule for type inference purposes
(let CANDIDATE_RULES (set-of (NormalRule (Num 1) (Num 1))))
(let CANDIDATE_CONDITIONAL_RULES (set-of (ConditionalRule (PredOp2 (Eq) (Num 0) (Num 0)) (Num 0) (Num 0))))

;;; find non-conditional rules.
(rule
  ((HasMathCvec ?a ?cvec1)
   (HasMathCvec ?b ?cvec2)
   (set-not-contains CANDIDATE_RULES (NormalRule ?a ?b))
   (!= ?a ?b)
   (= ?cvec1 ?cvec2))
  ((set-insert CANDIDATE_RULES (NormalRule ?a ?b))))

;;; find conditional rules.
(relation HasMatch (PredCvec MathCvec MathCvec))

(HasMatch (PredNil) (MathNil) (MathNil))

(rule
  ((PredCons ?p1 ?ptail)
   (MathCons ?m1 ?tail1)
   (MathCons ?m2 ?tail2)
   (= ?p1 true)
   (= ?m1 ?m2)
   (HasMatch ?ptail ?tail1 ?tail2))
  ((HasMatch
   (PredCons ?p1 ?ptail)
   (MathCons ?m1 ?tail1)
   (MathCons ?m2 ?tail2))))

(rule
  ((PredCons ?p1 ?ptail)
   (MathCons ?m1 ?tail1)
   (MathCons ?m2 ?tail2)
   (!= ?p1 true)
   (!= ?m1 ?m2)
   (HasMatch ?ptail ?tail1 ?tail2))
  ((HasMatch
   (PredCons ?p1 ?ptail)
   (MathCons ?m1 ?tail1)
   (MathCons ?m2 ?tail2))))

(rule
 ((HasMathCvec ?t1 ?c1)
  (HasMathCvec ?t2 ?c2)
  (HasPredCvec ?pred ?p1)
  (HasMatch ?p1 ?c1 ?c2))
 ((set-insert CANDIDATE_CONDITIONAL_RULES
   (ConditionalRule ?pred ?t1 ?t2))))

(let expr0 (Var "x"))
(let expr1 (MathOp2 (Div) expr0 expr0))
(let expr2 (Num 0))
(let expr3 (Num 1))

(let pred0 (PredOp2 (Neq) expr0 expr2))


(run 10000)

(check (ConditionalRule pred0 expr1 expr3))


